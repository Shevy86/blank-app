"""
Vulnerability Scanner Module
Scans IP addresses and URLs for common security vulnerabilities
"""

import socket
import ssl
import urllib.parse
import re
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import urllib.request
import concurrent.futures


@dataclass
class ScanResult:
    """Represents a vulnerability scan finding"""
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    title: str
    description: str
    recommendation: str
    details: Dict[str, Any] = None


class VulnerabilityScanner:
    """Scans IPs and URLs for security vulnerabilities"""

    # Common ports to scan
    COMMON_PORTS = {
        21: "FTP",
        22: "SSH",
        23: "Telnet",
        25: "SMTP",
        53: "DNS",
        80: "HTTP",
        110: "POP3",
        143: "IMAP",
        443: "HTTPS",
        445: "SMB",
        3306: "MySQL",
        3389: "RDP",
        5432: "PostgreSQL",
        6379: "Redis",
        8080: "HTTP-Alt",
        8443: "HTTPS-Alt",
        27017: "MongoDB"
    }

    # Dangerous ports that shouldn't be exposed
    DANGEROUS_PORTS = {
        21: "FTP - unencrypted file transfer",
        23: "Telnet - unencrypted remote access",
        445: "SMB - often targeted by ransomware",
        3306: "MySQL - database should not be publicly exposed",
        3389: "RDP - common attack vector",
        5432: "PostgreSQL - database should not be publicly exposed",
        6379: "Redis - often misconfigured without auth",
        27017: "MongoDB - often misconfigured without auth"
    }

    def __init__(self):
        self.timeout = 5  # Socket timeout in seconds

    def scan_ip(self, ip: str) -> Dict[str, Any]:
        """Scan an IP address for open ports and vulnerabilities"""
        findings = []
        open_ports = []
        scan_start = datetime.now()

        # Validate IP format
        if not self._is_valid_ip(ip):
            return {
                "target": ip,
                "target_type": "ip",
                "status": "error",
                "error": "Invalid IP address format",
                "findings": [],
                "risk_score": 0
            }

        # Port scan
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            future_to_port = {
                executor.submit(self._check_port, ip, port): port
                for port in self.COMMON_PORTS.keys()
            }

            for future in concurrent.futures.as_completed(future_to_port):
                port = future_to_port[future]
                try:
                    is_open = future.result()
                    if is_open:
                        open_ports.append(port)
                        service = self.COMMON_PORTS.get(port, "Unknown")

                        # Check if dangerous port
                        if port in self.DANGEROUS_PORTS:
                            findings.append(ScanResult(
                                severity="HIGH",
                                title=f"Dangerous Port Open: {port} ({service})",
                                description=self.DANGEROUS_PORTS[port],
                                recommendation=f"Close port {port} or restrict access via firewall rules.",
                                details={"port": port, "service": service}
                            ))
                        else:
                            findings.append(ScanResult(
                                severity="INFO",
                                title=f"Open Port: {port} ({service})",
                                description=f"Port {port} ({service}) is accessible.",
                                recommendation="Ensure this port is intentionally exposed and properly secured.",
                                details={"port": port, "service": service}
                            ))
                except Exception as e:
                    pass  # Port check failed, likely filtered/closed

        # Calculate risk score
        risk_score = self._calculate_ip_risk_score(findings, open_ports)

        return {
            "target": ip,
            "target_type": "ip",
            "status": "completed",
            "scan_duration": (datetime.now() - scan_start).total_seconds(),
            "open_ports": open_ports,
            "findings": [self._finding_to_dict(f) for f in findings],
            "risk_score": risk_score,
            "summary": {
                "total_ports_scanned": len(self.COMMON_PORTS),
                "open_ports": len(open_ports),
                "critical_findings": len([f for f in findings if f.severity == "CRITICAL"]),
                "high_findings": len([f for f in findings if f.severity == "HIGH"]),
                "medium_findings": len([f for f in findings if f.severity == "MEDIUM"])
            }
        }

    def scan_url(self, url: str) -> Dict[str, Any]:
        """Scan a URL for web vulnerabilities and security headers"""
        findings = []
        scan_start = datetime.now()

        # Normalize URL
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url

        parsed = urllib.parse.urlparse(url)
        hostname = parsed.netloc

        # SSL/TLS Check
        if parsed.scheme == 'https':
            ssl_findings = self._check_ssl(hostname)
            findings.extend(ssl_findings)
        else:
            findings.append(ScanResult(
                severity="HIGH",
                title="No HTTPS",
                description="Site does not use HTTPS encryption.",
                recommendation="Enable HTTPS with a valid SSL certificate."
            ))

        # HTTP Security Headers Check
        header_findings = self._check_security_headers(url)
        findings.extend(header_findings)

        # Check for common security issues
        security_findings = self._check_common_web_issues(url)
        findings.extend(security_findings)

        # Calculate risk score
        risk_score = self._calculate_url_risk_score(findings)

        return {
            "target": url,
            "target_type": "url",
            "status": "completed",
            "scan_duration": (datetime.now() - scan_start).total_seconds(),
            "findings": [self._finding_to_dict(f) for f in findings],
            "risk_score": risk_score,
            "summary": {
                "critical_findings": len([f for f in findings if f.severity == "CRITICAL"]),
                "high_findings": len([f for f in findings if f.severity == "HIGH"]),
                "medium_findings": len([f for f in findings if f.severity == "MEDIUM"]),
                "low_findings": len([f for f in findings if f.severity == "LOW"]),
                "info_findings": len([f for f in findings if f.severity == "INFO"])
            }
        }

    def _check_port(self, ip: str, port: int) -> bool:
        """Check if a port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except:
            return False

    def _check_ssl(self, hostname: str) -> List[ScanResult]:
        """Check SSL/TLS configuration"""
        findings = []

        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    protocol = ssock.version()

                    # Check certificate expiry
                    not_after = cert.get('notAfter', '')
                    if not_after:
                        from datetime import datetime
                        expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (expiry - datetime.now()).days

                        if days_until_expiry < 0:
                            findings.append(ScanResult(
                                severity="CRITICAL",
                                title="SSL Certificate Expired",
                                description=f"Certificate expired {abs(days_until_expiry)} days ago.",
                                recommendation="Renew the SSL certificate immediately."
                            ))
                        elif days_until_expiry < 30:
                            findings.append(ScanResult(
                                severity="MEDIUM",
                                title="SSL Certificate Expiring Soon",
                                description=f"Certificate expires in {days_until_expiry} days.",
                                recommendation="Renew the SSL certificate before expiration."
                            ))
                        else:
                            findings.append(ScanResult(
                                severity="INFO",
                                title="Valid SSL Certificate",
                                description=f"Certificate valid for {days_until_expiry} more days.",
                                recommendation="Continue monitoring certificate expiration.",
                                details={"days_until_expiry": days_until_expiry}
                            ))

                    # Check protocol version
                    if 'TLSv1.0' in protocol or 'TLSv1.1' in protocol:
                        findings.append(ScanResult(
                            severity="HIGH",
                            title="Outdated TLS Version",
                            description=f"Server supports {protocol}, which is deprecated.",
                            recommendation="Upgrade to TLS 1.2 or TLS 1.3."
                        ))
                    elif 'TLSv1.3' in protocol:
                        findings.append(ScanResult(
                            severity="INFO",
                            title="Modern TLS Version",
                            description="Server uses TLS 1.3.",
                            recommendation="Good - maintain current configuration."
                        ))

        except ssl.SSLCertVerificationError as e:
            findings.append(ScanResult(
                severity="CRITICAL",
                title="SSL Certificate Verification Failed",
                description=str(e),
                recommendation="Obtain a valid SSL certificate from a trusted CA."
            ))
        except Exception as e:
            findings.append(ScanResult(
                severity="MEDIUM",
                title="SSL Check Failed",
                description=f"Could not verify SSL: {str(e)}",
                recommendation="Verify SSL configuration manually."
            ))

        return findings

    def _check_security_headers(self, url: str) -> List[ScanResult]:
        """Check for security headers"""
        findings = []

        required_headers = {
            'Strict-Transport-Security': {
                'severity': 'MEDIUM',
                'description': 'HSTS header missing - site vulnerable to protocol downgrade attacks',
                'recommendation': 'Add Strict-Transport-Security header with appropriate max-age'
            },
            'X-Content-Type-Options': {
                'severity': 'LOW',
                'description': 'X-Content-Type-Options header missing - potential MIME sniffing vulnerability',
                'recommendation': 'Add X-Content-Type-Options: nosniff header'
            },
            'X-Frame-Options': {
                'severity': 'MEDIUM',
                'description': 'X-Frame-Options header missing - site may be vulnerable to clickjacking',
                'recommendation': 'Add X-Frame-Options: DENY or SAMEORIGIN header'
            },
            'Content-Security-Policy': {
                'severity': 'MEDIUM',
                'description': 'Content-Security-Policy header missing - increased XSS risk',
                'recommendation': 'Implement a Content-Security-Policy header'
            },
            'X-XSS-Protection': {
                'severity': 'LOW',
                'description': 'X-XSS-Protection header missing',
                'recommendation': 'Add X-XSS-Protection: 1; mode=block header'
            }
        }

        try:
            req = urllib.request.Request(url, headers={'User-Agent': 'VCSO-Security-Scanner/1.0'})
            with urllib.request.urlopen(req, timeout=self.timeout) as response:
                headers = {k.lower(): v for k, v in response.getheaders()}

                for header, config in required_headers.items():
                    if header.lower() not in headers:
                        findings.append(ScanResult(
                            severity=config['severity'],
                            title=f"Missing Security Header: {header}",
                            description=config['description'],
                            recommendation=config['recommendation']
                        ))
                    else:
                        findings.append(ScanResult(
                            severity="INFO",
                            title=f"Security Header Present: {header}",
                            description=f"Header value: {headers[header.lower()][:100]}",
                            recommendation="Verify header value is appropriate."
                        ))

                # Check for information disclosure
                if 'server' in headers:
                    findings.append(ScanResult(
                        severity="LOW",
                        title="Server Version Disclosure",
                        description=f"Server header reveals: {headers['server']}",
                        recommendation="Remove or obfuscate the Server header."
                    ))

                if 'x-powered-by' in headers:
                    findings.append(ScanResult(
                        severity="LOW",
                        title="Technology Disclosure",
                        description=f"X-Powered-By header reveals: {headers['x-powered-by']}",
                        recommendation="Remove the X-Powered-By header."
                    ))

        except Exception as e:
            findings.append(ScanResult(
                severity="MEDIUM",
                title="Header Check Failed",
                description=f"Could not check headers: {str(e)}",
                recommendation="Verify the URL is accessible."
            ))

        return findings

    def _check_common_web_issues(self, url: str) -> List[ScanResult]:
        """Check for common web security issues"""
        findings = []
        parsed = urllib.parse.urlparse(url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"

        # Check for common sensitive files
        sensitive_paths = [
            '/.git/config',
            '/.env',
            '/wp-config.php.bak',
            '/config.php.bak',
            '/.htaccess',
            '/phpinfo.php',
            '/server-status',
            '/robots.txt',
            '/sitemap.xml',
            '/.well-known/security.txt'
        ]

        for path in sensitive_paths:
            try:
                test_url = base_url + path
                req = urllib.request.Request(test_url, headers={'User-Agent': 'VCSO-Security-Scanner/1.0'})
                with urllib.request.urlopen(req, timeout=3) as response:
                    if response.status == 200:
                        if path in ['/.git/config', '/.env', '/wp-config.php.bak', '/config.php.bak']:
                            findings.append(ScanResult(
                                severity="CRITICAL",
                                title=f"Sensitive File Exposed: {path}",
                                description=f"The file {path} is publicly accessible.",
                                recommendation=f"Immediately restrict access to {path}."
                            ))
                        elif path == '/phpinfo.php':
                            findings.append(ScanResult(
                                severity="HIGH",
                                title="PHPInfo Exposed",
                                description="phpinfo.php is accessible, revealing server configuration.",
                                recommendation="Remove phpinfo.php from production."
                            ))
                        elif path == '/server-status':
                            findings.append(ScanResult(
                                severity="MEDIUM",
                                title="Server Status Exposed",
                                description="Apache server-status is accessible.",
                                recommendation="Restrict access to server-status."
                            ))
                        elif path == '/.well-known/security.txt':
                            findings.append(ScanResult(
                                severity="INFO",
                                title="Security.txt Present",
                                description="security.txt file found - good practice.",
                                recommendation="Ensure security.txt is up to date."
                            ))
            except:
                pass  # File not found or not accessible

        return findings

    def _is_valid_ip(self, ip: str) -> bool:
        """Validate IP address format"""
        try:
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                if not 0 <= int(part) <= 255:
                    return False
            return True
        except:
            return False

    def _calculate_ip_risk_score(self, findings: List[ScanResult], open_ports: List[int]) -> float:
        """Calculate risk score for IP scan"""
        score = 100  # Start with perfect score

        for finding in findings:
            if finding.severity == "CRITICAL":
                score -= 25
            elif finding.severity == "HIGH":
                score -= 15
            elif finding.severity == "MEDIUM":
                score -= 10
            elif finding.severity == "LOW":
                score -= 5

        # Penalize for dangerous open ports
        dangerous_open = len([p for p in open_ports if p in self.DANGEROUS_PORTS])
        score -= dangerous_open * 10

        return max(0, min(100, score))

    def _calculate_url_risk_score(self, findings: List[ScanResult]) -> float:
        """Calculate risk score for URL scan"""
        score = 100

        for finding in findings:
            if finding.severity == "CRITICAL":
                score -= 25
            elif finding.severity == "HIGH":
                score -= 15
            elif finding.severity == "MEDIUM":
                score -= 8
            elif finding.severity == "LOW":
                score -= 3

        return max(0, min(100, score))

    def _finding_to_dict(self, finding: ScanResult) -> Dict[str, Any]:
        """Convert finding to dictionary"""
        return {
            "severity": finding.severity,
            "title": finding.title,
            "description": finding.description,
            "recommendation": finding.recommendation,
            "details": finding.details or {}
        }
